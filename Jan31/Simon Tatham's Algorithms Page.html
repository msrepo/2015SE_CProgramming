<html><head>
<meta http-equiv="content-type" content="text/html; charset=windows-1252">
<title>Simon Tatham's Algorithms Page</title>
<link rel="stylesheet" type="text/css" href="Simon%20Tatham%27s%20Algorithms%20Page_files/sitestyle.css" name="Simon Tatham's Home Page Style"></head>

<body>
<h1 align="center">Simon Tatham's Algorithms Page</h1>

<p>
This web page is a repository for algorithms, maintained by
<a href="http://www.chiark.greenend.org.uk/%7Esgtatham/">Simon Tatham</a>.
Its purposes are:

</p><ul>
<li>
To provide unusual algorithms to people who might have a use for
them.
</li><li>
To make interesting reading for people who are into algorithm design.
</li><li>
To act as prior art in case anybody else tries to patent one of
these algorithms.
</li></ul>

<p>
In addition to actual algorithms, I've also got a couple of unsolved
problems, in the hope that people might send me ideas on how to
solve them.

</p><p>
If you have an interesting and unusual algorithm and would like it
stored on this site,
<a href="mailto:anakin@pobox.com">send it to me</a>
and I might well add it. If you could write it up in HTML in a form
that looks like the existing pages, that would be helpful.

</p><p>
Algorithms on this site <em>don't</em> have to be new and undiscovered
inventions. They only have to be unusual enough not to show up in
the average algorithms textbook.

</p><p>
So, enough of the introduction. Time for some actual algorithms.

</p><h2>Algorithms I have invented</h2>

<p>
(Disclaimer: I don't intend to imply that nobody else has ever
thought of these algorithms. They might easily have done. The nice
thing about not patenting them is that I don't have to know for sure
whether they're original or not :-)

</p><dl>
<dt>
<a href="http://www.chiark.greenend.org.uk/%7Esgtatham/algorithms/cumulative.html">Cumulative frequency tables</a>
</dt><dd>
A quick (log-time) mechanism for maintaining a cumulative frequency
table. Useful in adaptive compression methods (particularly
arithmetic compression). Might also have applications in assembly or
code generation.

</dd><dt>
<a href="http://www.chiark.greenend.org.uk/%7Esgtatham/algorithms/blocksort.html">A block-sorting approach to string
searching</a>
</dt><dd>
A method of searching one string for another, inspired by the
Burrows-Wheeler transform. Unlike most searching algorithms, which
are optimised to search for one needle in a large amount of haystack
text, this algorithm is optimised to take one fixed haystack and
search it very fast for lots of different needles.

</dd><dt>
<a href="http://www.chiark.greenend.org.uk/%7Esgtatham/algorithms/listsort.html">Sorting a linked list using Mergesort</a>
</dt><dd>
All the serious computer-science literature about sorting tells you
how to do it on arrays. As it turns out, sorting a linked list is
much easier, but nobody actually bothers to <em>tell</em> you about
it. Well, I do, and here's how you can use a variant of Mergesort to
sort a linked list in reliable <code>O(N log N)</code> time, with no
worst cases, no auxiliary storage requirements, <em>and</em> stably.

</dd><dt>
<a href="http://www.chiark.greenend.org.uk/%7Esgtatham/algorithms/cbtree.html">Counted B-trees</a>
</dt><dd>
An enhancement to the well known B-tree algorithms to allow you to
look up items in the tree by numeric index, or to find the numeric
index of an item. Useful for finding percentiles, for deciding on a
strategy for a complex search operation, or for storing items in a
B-tree in arbitrary order without a sorting criterion.

</dd><dt>
<a href="http://www.chiark.greenend.org.uk/%7Esgtatham/algorithms/revlist.html">Reversible linked lists</a>
</dt><dd>
A modified form of doubly linked list, which allows an arbitrary
section of a list to be <em>reversed</em> in constant time, simply by
changing a few pointers around, like any list splice operation.
Completely useless as far as I know, but very cute.

</dd></dl>

<h2>Unsolved problems: algorithms I wish I knew</h2>

<dl>

<dt>
<a href="http://www.chiark.greenend.org.uk/%7Esgtatham/algorithms/equivalence.html">Equivalence relations</a>
</dt><dd>
I'd like a data structure that represents an equivalence relation on
a given set, so that you start off assuming everything to be
equivalent, and gradually split equivalence classes as more and more
distinctions are found between elements. Applications include state
machine construction, but I'm sure there are others.

</dd></dl>

<hr>
(comments to <a href="mailto:anakin@pobox.com">anakin@pobox.com</a>)
<br>
(thanks to
<a href="http://www.chiark.greenend.org.uk/">chiark</a>
for hosting this page)
<br>
(last modified on <!--LASTMOD-->Sat Dec 11 09:44:22 2004<!--END-->)


</body></html>